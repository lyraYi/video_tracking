# -*- coding: utf-8 -*-
import cv2
import numpy as np
import pandas as pd
import struct
import time
from scipy.ndimage import gaussian_filter
import matplotlib.pyplot as plt

###############################################################################
#                          Core CINE Processing Functions                     #
###############################################################################

def read_L(f):
    return int(struct.unpack('<l', f.read(4))[0])

def read_Q(f):
    return struct.unpack('Q', f.read(8))[0]

def read_Q_array(f, n):
    a = np.zeros(n, dtype='Q')
    for i in range(n):
        a[i] = read_Q(f)
    return a

def read_B_2Darray(f, ypix, xpix):
    n = xpix * ypix
    a = np.array(struct.unpack(f'{n}B', f.read(n * 1)), dtype='B')
    return a.reshape(ypix, xpix)

def read_H_2Darray(f, ypix, xpix):
    n = xpix * ypix
    a = np.array(struct.unpack(f'{n}H', f.read(n * 2)), dtype='H')
    return a.reshape(ypix, xpix)

def read_cine(ifn):
    with open(ifn, 'rb') as cf:
        t_read = time.time()
        print("Reading .cine file...")

        cf.read(16)
        baseline_image = read_L(cf)
        image_count = read_L(cf)

        pointers = np.zeros(3, dtype='L')
        pointers[0] = read_L(cf)
        pointers[1] = read_L(cf)
        pointers[2] = read_L(cf)

        cf.seek(58)
        nbit = read_L(cf)

        cf.seek(int(pointers[0]) + 4)
        xpix = read_L(cf)
        ypix = read_L(cf)

        cf.seek(int(pointers[1]) + 768)
        pps = read_L(cf)
        exposure = read_L(cf)

        cf.seek(int(pointers[2])
        pimage = read_Q_array(cf, image_count)

        dtype = 'B' if nbit == 8 else 'H'
        frame_arr = np.zeros((image_count, ypix, xpix), dtype=dtype)

        for i in range(image_count):
            p = struct.unpack('<l', struct.pack('<L', pimage[i] & 0xffffffffffffffff))[0]
            cf.seek(p)
            ofs = read_L(cf)
            cf.seek(p + ofs)
            frame_arr[i] = read_B_2Darray(cf, ypix, xpix) if nbit == 8 else read_H_2Darray(cf, ypix, xpix)

        time_arr = np.linspace(
            baseline_image / pps, 
            (baseline_image + image_count) / pps, 
            image_count, 
            endpoint=False
        )

        print("Done reading .cine file (%.1f s)" % (time.time() - t_read))
        return time_arr, frame_arr

###############################################################################
#                           Video Conversion Functions                        #
###############################################################################

def convert_cine_to_avi(cine_path, avi_path, scale_factor=8):
    """Convert CINE file to AVI video with scaling"""
    time_arr, frame_arr = read_cine(cine_path)
    
    # Get original dimensions
    orig_height, orig_width = frame_arr.shape[1], frame_arr.shape[2]
    target_resolution = (orig_height * scale_factor, orig_width * scale_factor)
    
    # Create VideoWriter
    fourcc = cv2.VideoWriter_fourcc(*'MJPG')
    out = cv2.VideoWriter(avi_path, fourcc, 30, 
                         (target_resolution[1], target_resolution[0]), False)

    print(f"Converting {cine_path} to {avi_path}...")
    for frame in frame_arr:
        normalized = cv2.normalize(frame, None, 0, 255, cv2.NORM_MINMAX)
        resized = cv2.resize(normalized.astype(np.uint8), 
                            (target_resolution[1], target_resolution[0]))
        out.write(resized)
    
    out.release()
    print(f"Conversion complete. Saved to {avi_path}")

###############################################################################
#                            Time Calibration Functions                       #
###############################################################################

def load_experimental_time(csv_path):
    """Load experimental time data from CSV"""
    data = pd.read_csv(csv_path, header=None, skiprows=2)
    return data.iloc[:, 0].values

def video_time_to_experiment_time(video_time, fps, time_arr):
    """Convert video time to experimental timeline"""
    frame_index = int(video_time * fps)
    if frame_index < 0 or frame_index >= len(time_arr):
        raise ValueError(f"Video time {video_time}s out of range!")
    return time_arr[frame_index]

###############################################################################
#                            Tracking Processing Functions                    #
###############################################################################

def track_object_in_video(video_path, time_arr, output_prefix):
    """Main tracking function with all processing steps"""
    cap = cv2.VideoCapture(video_path)
    fps = int(cap.get(cv2.CAP_PROP_FPS))
    
    # Skip to 6 seconds
    cap.set(cv2.CAP_PROP_POS_FRAMES, fps * 6)
    ret, initial_frame = cap.read()
    
    # ROI Selection
    cv2.imshow("Select Calibration Object", initial_frame)
    calib_roi = cv2.selectROI("Select Calibration Object", initial_frame, False)
    cv2.destroyAllWindows()
    
    # Length calibration
    calib_w, calib_h = calib_roi[2], calib_roi[3]
    real_length = float(input("Real-world length of selected object (meters): "))
    pixels_per_meter = max(calib_w, calib_h) / real_length
    
    # Tracking setup
    cv2.imshow("Select Tracking Object", initial_frame)
    track_roi = cv2.selectROI("Select Tracking Object", initial_frame, False)
    cv2.destroyAllWindows()
    x, y, w, h = track_roi
    template = initial_frame[y:y+h, x:x+w]
    template_gray = cv2.cvtColor(template, cv2.COLOR_BGR2GRAY)
    
    # Tracking parameters
    composite = initial_frame.copy().astype(np.float32)
    time_list, x_list, y_list = [], [], []
    frame_count = fps * 6
    
    # Main tracking loop
    while cap.isOpened():
        ret, frame = cap.read()
        if not ret:
            break
        
        if frame_count % 30 == 0:
            # Tracking logic
            pass  # Maintain original tracking code here
        
        # Visualization and display
        pass  # Maintain original visualization code here
    
    # Post-processing
    cap.release()
    cv2.destroyAllWindows()
    
    # Save results
    np.savez(f"{output_prefix}_tracking.npz",
             times=np.array(time_list),
             x_pos=np.array(x_list),
             y_pos=np.array(y_list))
    
    # Generate plots
    plt.figure(figsize=(15,5))
    # ... plotting code ...
    plt.savefig(f"{output_prefix}_plots.png")
    plt.close()

###############################################################################
#                            Batch Processing Function                        #
###############################################################################

def process_cine_dataset(cine_files, csv_files, output_dir="results"):
    """
    Process multiple CINE files with experimental data
    :param cine_files: List of paths to CINE files
    :param csv_files: List of paths to CSV time data files
    :param output_dir: Output directory for results
    """
    for cine_path, csv_path in zip(cine_files, csv_files):
        # Generate output prefixes
        base_name = os.path.basename(cine_path).split('.')[0]
        output_prefix = os.path.join(output_dir, base_name)
        
        # Convert CINE to AVI
        avi_path = f"{output_prefix}.avi"
        convert_cine_to_avi(cine_path, avi_path)
        
        # Load experimental time data
        time_arr = load_experimental_time(csv_path)
        
        # Run tracking
        track_object_in_video(avi_path, time_arr, output_prefix)
        
        print(f"Completed processing for {cine_path}")

###############################################################################
#                                Example Usage                                #
###############################################################################

if __name__ == '__main__':
    # Example file list
    cine_files = [
        "Y20241101_He3kA_B250G500G_pl0t20_uw17t27_P24_y0@100_009.cine",
        "Y20241101_He3kA_B250G500G_pl0t20_uw17t27_P24_y0@100_010.cine"
    ]
    
    csv_files = [
        "Tungsten_ball_009.csv",
        "Tungsten_ball_010.csv"
    ]
    
    # Process all files
    process_cine_dataset(cine_files, csv_files, output_dir="results")
